### 1. mysql聚簇索引的页分裂原理实例分析?

#### 为什么会产生页分裂？

在MySQL中，MyISAM采用的是非聚簇索引的，InnoDB存储引擎是采用聚簇索引的。

聚簇结构的特点：

- 根据主键查询条目时,不用回行(数据就在主键节点下)
- 如果碰到不规则数据插入时,造成频繁的页分裂

这是因为聚簇索引采用的是**平衡二叉树算法**，而且每个节点都保存了该主键所对应行的数据，假设插入数据的主键是自增长的，那么根据二叉树算法会很快的把该数据添加到某个节点下，而其他的节点不用动；但是如果插入的是不规则的数据，那么每次插入都会改变二叉树之前的数据状态。从而导致了页分裂。

结论：

聚簇索引的主键值,应尽量是连续增长的值,而不是要是随机值, (不要用随机字符串或UUID)，否则会造成大量的页分裂与页移动。在使用InnoDB的时候最好定义成：

### 2. 什么是索引?

索引是一种数据结构,可以帮助我们快速的进行数据的查找.

### 3. 索引是个什么样的数据结构呢?

索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.

### 4. Hash索引和B+树所有有什么区别或者说优劣呢?

首先要知道Hash索引和B+树索引的底层实现原理:

hash索引底层就是**hash表**,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是**多路平衡查找树**.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.

- hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.
- B+树索引 适合范围查找

### 5. 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?

聚簇索引就是主键索引，主键索引的叶子节点存储的是整行数据

### 6. 非聚簇索引一定会回表查询吗?

不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.

举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.

### 7. 索引的常见模型？

哈希表、有序数组和搜索树。

### 8. 索引类型分为主键索引和非主键索引？

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

### 9. 在建立索引的时候,都有哪些需要考虑的因素呢?

- 建立索引的时候一般要考虑到字段的使用频率
- 建立联合索引的话,还需要考虑联合索引中的顺序.
- 此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.

### 10. 联合索引是什么?为什么需要注意联合索引中的顺序?

MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.

### 11. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?

MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.

### 12. mysql 锁?

- 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)

- 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。

另一类表级的锁是 MDL（metadata lock) MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。防止在执行期间另一个线程对这个表结构做变更。

### 13.怎么看死锁？
执行 show engine innodb status 命令

LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。


### 14.explain 优化之后 如何查看mysql 优化器优化信息？
```
select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/
show warnings
```

### 15. optimize table、analyze table 和 alter table 这三种方式重建表的区别?

- 从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是Online DDL 过程
- analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；
- optimize table t 等于 recreate+analyze。

### 16. 一个表中有大量的数据空洞？如何解决

使用 alter table t engine = InnoDB; 重建表

### 16. MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。简单描述一下引入了 Online DDL 之后，重建表的流程?

- 建立一个临时文件，扫描表 A 主键的所有数据页；
- 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
- 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中
- 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件
- 用临时文件替换表 A 的数据文件。

### 17. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?

- 使用不等于查询,
- 使用了函数运算
- 在字符串like时左边是通配符.类似于'%aaa'.
- 当mysql分析全表扫描比使用索引快的时候不使用索引.

### 18. 事务相关？

1. 什么是事务?

事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.

2. ACID是什么?可以详细说一下吗?

A=Atomicity

原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.

C=Consistency

系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.

I=Isolation

隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.

D=Durability

持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.

3. 同时有多个事务在进行会怎么样呢?

多事务的并发进行一般会造成以下几个问题:

- 脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- 不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
- 幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".

4. Innodb使用的是哪种隔离级别呢?

InnoDB默认使用的是可重复读隔离级别.